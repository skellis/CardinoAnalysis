"""
.. module: ultilities
:platform Windows
.. module author:: Scott R. Ellis <skellis@berkeley.edu>
Utilites is a collection of routines for performing data analysis on the data generated by the Cardino trace nitrogenous gas detector.
Ultimately a data routine will be performed by a short series of commands which are operated an second python script or within the python environment.
Example commands have been included in the comments which are illistrative. The commands have been designed to require minimal arguements and still work
but numerous optional commands are available.


"""

import numpy as np
import matplotlib.pyplot as plt
import itertools
import time
import os
#import sys
#np.set_printoptions(threshold=sys.maxsize)

def buildMonoDictionary(filename):
	"""
	A module for building a dictionary from the headers of your chosen data file.
	:param string filename: path to the desired data file

	returns dictionary: monoDict

	Example
	************************
	monoDict=buildMonoDictionary("2000_01_01 00_00_00 CARDINO.csv")
	"""
	labels =np.genfromtxt(filename ,dtype="str",delimiter=",",max_rows=1)
	indicies=range(0,len(labels))
	monoDict=dict(zip(labels,indicies))
	return monoDict

def buildGroupDictionary():
	"""
	A module for building a dictionary which organizes the differenc groups of data for example cavity pressures or zeroing states ect.
	This file will need to be updated if the data files are ever changed.
	
	returns dictionary groupDict

	Example
	************************
	groupDict=buildGroupDictionary()
	"""
	groupDict={"all":range(80),
	"TimeStamp":(0),
	"Taus":range(1,5),#NOTE!!! The O3 and NO2 ringdown times (Tau_O3) are not being written as of June 27 2019!!!!
	"Pressures":range(16,26),
	"Cavity Pressures":range(23,27),
	"Line Pressures":(16,18),
	"Tank Pressures":(17,19),
	"Temperatures":range(10,14),
	"Cavity Temperatures":range(10,13),
	"States":range(5,7),
	"Laser Currents":(8,9),
	"MFC":range(36,63),
	"MFC A":range(36,39),
	"Valves":range(27,35),
	"Setpoints":range(63,70),
	"Heaters":range(72,74),
	"Dongle":range(75,77),
	"ZeroData":range(6,7)
	}
	return groupDict

def combineDictionaries(dict1,dict2):
	"""
	A module for combining two dictionaries into one.
	param dictionary: dict1
	************************
	fullDict=combineDictionaries(monoDict,groupDict)
	"""
	dict3={**dict1,**dict2}
	return dict3

def getLabelDictionary(dictionaryFile="",filename="",save=False):
	"""
	A module for combining aquiring the dictionary of headers. An eternal dictionary can be loaded with dictionary file.
	A dictionary can be generated from a data file. Or the group dictionary can be used in no additional options are selected.
	This module can also save a new dictionary once it has been generated.
	

	optional param string: dictionaryFile path to the dictionary of labels to be loaded
	optional param string: filename path to the data file from which dictionary will be generated.
	optional param boolean: save should a new dictionary be saved in the current folder

	returns dictionary fd

	Example
	************************
	formerDictionary=getLabelDictionary(dictionaryFile="previousDict.txt")
	newDictionary=getLabelDictionary(filename="2000_01_01 00_00_00 CARDINO.csv")
	#Make a new dictionary file
	newDictionary=getLabelDictionary(filename="2000_01_01 00_00_00 CARDINO.csv",save=True)
	"""
	if (dictionaryFile!=""):
		log=open(dictionaryFile)
		fd=log.read()
		return fd
	gd=buildGroupDictionary()
	if (filename!=""):
		md=buildMonoDictionary(filename)
		fd=combineDictionaries(gd,md)
	else:
		fd=gd
	if save!=False:
		log=open("Dict"+time.strftime("%Y_%m_%d %H_%M_%S",time.gmtime()), "a")
		log.write(str(fd))
		log.close()
	return fd

def invertDictionary(dictionary):
	"""
	A module that takes a dictionary and inverts it so the entries are the definitions and the definitions are the entries.
	param dictionary: dictionary
	returns dictionary: inv_dictionary has been inverted

	Example
	************************
	inv_d=invertDictionary(d)
	"""
	inv_dictionary={v: k for k, v in dictionary.items()}
	return inv_dictionary

def getLabels(filename,columns="",**keyword_parameters):
	"""
	A module for extracting the labels from the data file for use in subsequent plotting or exporting functions.
	
	param string filename: data file where the labels are located.
	labeled optional parameter string: columns determines which columns you want selected i.e. "Valves"
	keyword_parameters tuple int: manualCol - Optional parameter for manually selecting which columns you want
	

	Example
	************************
		#*************************complet plotting example*************************
	time_Data=ut.loadCardinoData("2000_01_01 00_00_00 CARDINO.csv",columns="TimeStamp")
	time_Series=ut.formatTime(time_Data)
	#humidity_Data=ut.loadCardinoData("2019_06_26 14_30_56 CARDINO.csv",manualCol=(13))
	valve_Data=ut.loadCardinoData("2000_01_01 00_00_00 CARDINO.csv",columns="Valves")
	valve_Labels=ut.getLabels("2000_01_01 00_00_00 CARDINO.csv",columns="Valves")
	ut.plotCardino(time_Series,valve_Data,customLabel=valve_Labels,xlim=[500,1000])
	"""
	fdb=getLabelDictionary(filename=filename)
	if ('manualCol' in keyword_parameters):
		colRange=keyword_parameters['manualCol']
	elif(columns==""):
		print("Didn't indicate which columns to get labels from.")
		return ""
	else:
		colRange=fdb[columns]

	labels=np.genfromtxt(filename ,dtype="str",delimiter=",",max_rows=1,usecols=(colRange))
	return labels



def loadCardinoData(filename,columns="all",**keyword_parameters):
	"""
	A module for loading the Cardino data. The dictionary allows for rapid idexing of the desired data type.
	The timestamp data can be easily acquired too through use of the keyword parameters
	
	Params:

	filename- string - the path to the desired data file.
	columns - string - the name of the data you want to read. To be looked up in the dictionary colDict (default = "all").
	"all" returns all the data
	"timestamp" returns the time data.
	param string: filename path to data file to be loaded
	optional param string: columns: name of data to be referenced by dictionary default: "all"
	Keyword_parameters - includeTime - Optional parameter for getting the timeStamp in addition to a
	Keyword_parameters - manualCol - Optional parameter for manually selecting which columns you want.
	Keyword_parameters - skipHead - Optional parameter for skipping the initial rows of the data file


	Examples:
	******************
	o3cav_data=loadCardinoData("2019_06_26 14_30_56 CARDINO.csv",columns="TC4 O3 Cavity (Â°C)")
	all_data=loadCardinoData("2019_06_26 14_30_56 CARDINO.csv")
	time_Data,allTemperature_data=loadCardinoData("2019_06_26 14_30_56 CARDINO.csv",columns="Temperatures",includeTime=True)
	time_Data,humidity_Data=loadCardinoData("2019_06_26 14_30_56 CARDINO.csv",manualCol=(13),includeTime=True)
	time_Data=loadCardinoData("2019_06_26 14_30_56 CARDINO.csv",columns="TimeStamp")
	"""
	#makes sure your formatted your file name correctly
	if(filename[-4:]!=".csv"):
		filename+=".csv"
		print("File must be a .csv. Searching for :"+filename+"...")

	#The indicies of this dictionary will fail whenever you change the format of the .csv data file.
	#What follows is only an example of how a the data can groups easily.
	#These column indicies can be referenced manually outside this module by using a keyword parameter. 
	#deal with optional parameters.
	dataType="float"
	if (columns=="TimeStamp"):
		dataType="str"

	colDict=getLabelDictionary(filename=filename)
	#You can overide the dictonary indicies by using manualCol Keyword.
	if ('manualCol' in keyword_parameters):
		colRange=keyword_parameters['manualCol']
	else:
		colRange=colDict[columns]
	#We want to skip the header when extracting the data.
	#Note on ocassion he first 3 row of the .csv file were missing columns. If this is detected skipHead=5 is advisable.
	if ('skipHead' not in keyword_parameters):
		skipHead=4
	
	d=np.genfromtxt(filename ,dtype=dataType,skip_header=skipHead,delimiter=",",missing_values=np.nan,usecols=(colRange),autostrip=True)
	t= np.genfromtxt(filename ,dtype="str",skip_header=skipHead,delimiter=",",usecols=0,missing_values=np.nan,autostrip=True)
	
	if ('includeTime' in keyword_parameters):
		return t,d
	elif (columns=="TimeStamp"):
		return t
	else:
		return d


def formatTime(timeStamp):
	"""
	A module that takes the timestamp as a string array and reformats it as a time series array with the number of seconds which have passed since the measurement
	began. 
	#returns seconds in months + seconds in days +seconds in hours + seconds in minutes + seconds
	#takes sample TimeStamp:    2019.06.26 14:56:14.08
	
	Params:
	param list string: timeStamp
	returns list float: ts time series seconds

	Example
	************************
	timeSeries=ut.formatTime(timeStamp)
	"""

	tz=float(timeStamp[0][5:7])*365.25/12.*24.*60.*60.+float(timeStamp[0][8:10])*24.*60.*60.+float(timeStamp[0][11:13])*60.*60.+float(timeStamp[0][14:16])*60.+float(timeStamp[0][17:19])+float(timeStamp[0][20:22])/100.
	ty=np.zeros(len(timeStamp))
	for i in range(len(timeStamp)):
		ty[i]=float(timeStamp[i][5:7])*365.25/12.*24.*60.*60.+float(timeStamp[i][8:10])*24.*60.*60.+float(timeStamp[i][11:13])*60.*60.+float(timeStamp[i][14:16])*60.+float(timeStamp[i][17:19])+float(timeStamp[i][20:22])/100.
	ts=np.subtract(ty,tz)
	return ts


def plotCardino(timepoints,data,ylabel="Parameter (Unspecified Units)",title="Cardino Data",saveloc="",customLabel="",xlim=[],ylim=[]):
	"""
	A module for plotting cardino data and optionally saving the plot.
	
	Params:
	param list float: timepoints seconds that have elasped since the measurement bagan
	param list float: data to be plotted
	optional param string: ylabel label that goes on the y axis
	optional param string: title plot title
	optional param string: saveloc path where figure should be save default: ""
	optional param string list: custom label to go in legend default goes to "parameter 1, parameter 2" ect.
	optional list floats: xlim range of x axis time in seconds ex. [50,500] defualt is autoscale
	optional list floats: ylim range of y axis time in seconds ex. [50,500] defualt is autoscale
	
	Example:
	-----------------------------------
	plotCardino(time_Series,humidity_Data,title="Humidity Sensor", ylabel="% Humidity")
	plotCardino(time_Series,cavityPressure_Data,title="Cavity Pressure", ylabel="Pressure (mbar)",customLabel=["N2O5","NO3","NO2","O3"])
	plotCardino(time_Series,allTemperature_data,saveloc="plotAllTemperatures.png")
	
	#*************************complete plotting example*************************
	time_Data=ut.loadCardinoData("2000_01_01 00_00_00 CARDINO.csv",columns="TimeStamp")
	time_Series=ut.formatTime(time_Data)
	#humidity_Data=ut.loadCardinoData("2019_06_26 14_30_56 CARDINO.csv",manualCol=(13))
	valve_Data=ut.loadCardinoData("2000_01_01 00_00_00 CARDINO.csv",columns="Valves")
	valve_Labels=ut.getLabels("2000_01_01 00_00_00 CARDINO.csv",columns="Valves")
	ut.plotCardino(time_Series,valve_Data,customLabel=valve_Labels,xlim=[500,1000])

	
	"""

	fig, (ax) = plt.subplots(1, 1, sharex=True,constrained_layout=True)
	fig.suptitle(title)
	if(data.ndim>1):
		col=np.shape(data)[1]
	else:
		col=1
	#Check to see if custom labels have been implimented with the proper size to be used with the selected data.
	#If thy do have the proper size use them.
	if (len(customLabel)!=0 and len(customLabel)!=col):
		print("your labels must match the number of data arrays you entered")
	elif(len(customLabel)!=0 and len(customLabel)==col):
		for i in range(col):
			ax.plot(timepoints,data[0:,i],label=customLabel[i])
	#Default name will be parameter if labeling is not implimented.
	elif(col>1):
		for j in range(col):
			ax.plot(timepoints,data[0:,j],label='parameter '+str(j))
	else:
		ax.plot(timepoints,data,label='parameter')
	#set the limits of the plot
	if(len(xlim)!=0):
		plt.xlim(xlim)
	if(len(ylim)!=0):
		plt.ylim(ylim)

	ax.set_xlabel('Time (s)')
	ax.set_ylabel(ylabel)
	ax.legend()
	if (saveloc!=""):
		plt.savefig(saveloc)
	else:
		plt.show()

def exportCardinoData(saveloc="",*data,**keyword_parameters):
	"""
	module for exporting data to a .csv file after it has been processed. Note if an extension other than csv is used it automatically goes to a csv.
	
	Params:

	optional param string: saveloc name of file where data will be saved
	positional param list float: data any number of data can be included. The data will be addes as columns to the CSV file
	keyword_parametet string list: header a comma seperated string which contains the header which will be written above the columns 
	ex. "V1 Flight 1 Filter, V2 Flight 2 Filter,V3 Flight 3Filter, V4 Flight 4 Filter,V5 Three-way,V6 NO 100ppm,V7 NO 2000ppm, V8 Zero Air Red, V9 Zero Air Blue"

	Examples:

	exportCardino("timehumidityData.txt",time_Series,time_Data,humidity_Data,temperature_Data)
	
	#*************************complete exporting example*************************
	time_Data=ut.loadCardinoData("2000_01_01 00_00_00 CARDINO.csv",columns="TimeStamp")
	time_Series=ut.formatTime(time_Data)
	time_Labels=np.array(["Time (s)"])
	valve_Data=ut.loadCardinoData("2000_01_01 00_00_00 CARDINO.csv",columns="Valves")
	valve_Labels=ut.getLabels("2000_01_01 00_00_00 CARDINO.csv",columns="Valves")
	temp_Data=ut.loadCardinoData("2000_01_01 00_00_00 CARDINO.csv",columns="Temperatures")
	temp_Labels=ut.getLabels("2000_01_01 00_00_00 CARDINO.csv",columns="Temperatures")
	full_Labels=np.hstack((time_Labels,valve_Labels,temp_Labels))
	joined_labels= ut.joinLabels(time_Labels,valve_Labels,temp_Labels)
	ut.exportCardinoData("valve_temperature_20190703.csv",time_Series,valve_Data,temp_Data,header=joined_labels)
	"""
	if(len(data[0])==0):
		print("You didn't select any data")
		return
	if(saveloc==""):
		print("You didn't indicate a filename so we'll just label it: data_"+time.strftime("%Y_%m_%d %H_%M_%S",time.gmtime())+".csv")
		saveloc="data_"+time.strftime("%Y_%m_%d %H_%M_%S",time.gmtime())+".csv"
	elif(saveloc[-4]=="." and saveloc[-3:]!="csv"):
		print("Changing your " +saveloc[-4:]+" file to a .csv file")
		saveloc=saveloc[:-4]+".csv"
	elif(saveloc[-4:]!=".csv"):
		print("File will be saved as a .csv file instead.")
		saveloc+=".csv"
	log=open(saveloc, "a")
	print("Note: if you run the same code multiple times without updating the file name subsequent data date will be appended to the same file")
	if ('header' in keyword_parameters):
		header=keyword_parameters['header']
		log.write(header+"\r")
	
	line1=""
	line2=""
	for i in range(len(data[0])):
		for num in data:
			line1+=str(num[i])+","
		line2=line1[:-1]+"\r"
		log.write(line2)
		line1=""
		line2=""
	log.close()
	return

def joinLabels(*labels):
	"""
	A module for joining labels together from an array to a string with commas in it.
	
	Params:
	positional param: labels lists of strings to be joined into a string with commas.
	
	Examples:

	time_Labels=np.array(["Time (s)"])
	valve_Labels=ut.getLabels("2000_01_01 00_00_00 CARDINO.csv",columns="Valves")
	temp_Labels=ut.getLabels("2000_01_01 00_00_00 CARDINO.csv",columns="Temperatures")
	joined_labels= ut.joinLabels(time_Labels,valve_Labels,temp_Labels)
	"""
	jc=""
	jd=""
	for i in range(len(labels)):
		jc=labels[i]
		for j in range(len(jc)):
			jd+=jc[j]+","
	return jd[:-1]

def getZeroingAvg(taus, zeroingState,averageType=0):
	"""
	A module for getting the average values of each zeroing event.
	Can do the median or the mean. 
	Can take 1 tau column or 2 tau coluns.

	Params:

	param list floats: taus - cavity ringdown times data usually either the red or the blue cavities together or just one cavity
	param list floats: zeroingState flags of a either the blue or the red channels.
	0= warm up, 1 = normal, 2 = start zeroing, 3=Zeroing, 4 = stop zeroing
	optional boolean: averageType (default = 0) selects median or mean.
	averageType =0 (default) takes the median value of a zeroing event
	averageType =1 takes the mean value of a zeroing event
	

	Examples
	#*************************complete zeroing example*************************
	redState=ut.loadCardinoData("2019_07_05 16_26_54 CARDINO.csv",columns="Red State")
	blueState=ut.loadCardinoData("2019_07_05 16_26_54 CARDINO.csv",columns="Blue State")
	tau_Data=ut.loadCardinoData("2019_07_05 16_26_54 CARDINO.csv",columns="Taus")
	#The red ringdown times are in the first two columns of tau_Data
	#The blue ringdown times are in the second two columns of tau_Data
	redZeros=ut.getZeroingAvg(tau_Data[:,0:2], redState)
	blueZeros=ut.getZeroingAvg(tau_Data[:,2:4], blueState)
	"""
	#how many columns are in taus? 1 or 2?
	if(taus.ndim>1):
		col=np.shape(taus)[1]
	else:
		col=1
	startZeroIndex,stopZeroIndex=getZeroingIndicies(zeroingState)

	#create empty array of the corret size
	zeroValue=np.array([], dtype=np.int64).reshape(0,col)
	#select which average type to use 0=median, 1 =mean
	if(averageType==0):
		#Go through each zeroing even index and take the median.
		for i in range(len(startZeroIndex)):
			zeroValue=np.vstack((zeroValue,np.median(taus[startZeroIndex[i]:stopZeroIndex[i],:],axis=0)))
	elif(averageType==1):
		#Go through each zeroing even index and take the mean.
		for i in range(len(startZeroIndex)):
			zeroValue=np.vstack((zeroValue,np.mean(taus[startZeroIndex[i]:stopZeroIndex[i],:],axis=0)))
	#return the zero values.
	return zeroValue

def getZeroingIndicies(zeroingState):
	"""
	A module for getting the indicies for the start and the stop of the zeroing routine.
	
	Params
	param list floats: zeroingState flags of a either the blue or the red channels.

	Examples
	startZeroIndex,stopZeroIndex=getZeroingIndicies(zeroState)
	"""
	isZeroing=(zeroingState==3)
	#get an array of booleans where the zeroings state and the previous timepoint was 2.
	#this is the start of the zeroing
	startzeropoints=[(zeroingState[i]==3 and zeroingState[i-1]==2) for i in range(len(zeroingState))]
	#get the indecies of the start zeroing point
	startZeroIndex=np.array([qb for qb, x in enumerate(startzeropoints) if x],dtype=int)
	#get how long for each zeroing event.
	zeroDuration=np.array([ sum( 1 for _ in group ) for key, group in itertools.groupby( isZeroing ) if key ])
	#add the duration to the start indecies to get the stop indecies
	stopZeroIndex=startZeroIndex+zeroDuration
	return startZeroIndex,stopZeroIndex

def performZeroing(zeroValue,zeroingState,proximityType=0):
	"""
	A module for determining which zero value to use at which time point. getZeroingAvg should be run before this to determine zeroValue

	Params
	param array: zeroValue the average values for the individual zeroing events can be a 1xN dimensional array or a 2xN dimensional array
	where N is the length of the measurement.
	
	param list floats: zeroingState flags of a either the blue or the red channels.

	optional param proximityType (default=0) 

	0=take values of subsequent zero
	1=take value of closest zero

	returns

	array zpoints array of zero values to be used at each timepoint
	"""
	ip=0
	#needs to handle one or two channels at a time.
	if(zeroValue.ndim>1):
		dim=np.shape(zeroValue)[1]
	else:
		dim=1
	#identify where zeroing ended
	startZeroIndex,stopZeroIndex=getZeroingIndicies(zeroingState)
	if(dim==1):
		zpoints=np.array([]).reshape(0,)
		for i in range(len(zeroValue)):
			ca=np.ones(stopZeroIndex[i]-ip)*zeroValue[i]
			ip=stopZeroIndex[i]
			zpoints=np.hstack((zpoints,ca))
		extra=len(zeroingState)-len(zpoints)
		ca=np.ones(extra)*zeroValue[-1,0]
		zpoints=np.hstack((zpoints,ca))

	elif(dim>1):
		zpoints=np.array([]).reshape(0,dim)
		for i in range(len(zeroValue)):
			ca=np.ones((stopZeroIndex[i]-ip,dim))*zeroValue[i,:]
			ip=stopZeroIndex[i]
			zpoints=np.vstack((zpoints,ca))
		extra=len(zeroingState)-len(zpoints)
		ca=np.ones((extra,dim))*zeroValue[-1,:]
		zpoints=np.vstack((zpoints,ca))
	return zpoints

def calculateEpsilon(taus,zpoints):
	"""
	a module for calculating the attenuation coeficient from the ringdown times and the zeroed ringdown times.

	param array taus ringdown times of the red or the blue cavities
	param array zpoints corresponding zero ringdown times. Must have same dimensionality.
	
	returns array epsilon attenuation coeffcient in units of meters

	Examples:
	redZero_Array=performZeroing(redZeros,redState)
	"""
	C=299.792458#speed of light in meter/microsecond
	epsilon=C*(np.reciprocal(taus)-np.reciprocal(zpoints))
	return epsilon

def selectZeroState(data,zeroingState,desiredFlag=1):
	"""
	A module which turns all the data which is not in the desired zeroing state to np.nan.


	param array data in a time series measurement
	param array zeroingState: flags for zeroing measurement during time searies (blueState or redState)
	param int desiredFlag: determines which state  you select for 
	1: normal (default)
	0: warmup
	2: startZeroing
	3: Zeroing
	4: stopZeroing

	Example:
	#select the zeroing normal 
	epBlue_norm=ut.selectZeroState(epBlue,blueState)

	"""
	isZeroing=(zeroingState!=desiredFlag)
	data[isZeroing]=np.nan
	normalData=data
	return normalData

def trimData(data,sp,ep):
	"""
	A module for trimming the data to exclude undesireable regions at the start or the end of the data set.

	param array data in a time series measurement
	param int sp: starting point index
	param int ep: ending point index where the trim should stop


	"""
	if(data.ndim>1):
		dim=np.shape(data)[1]
		return data[sp:ep,:]
	else:
		dim=1
		return data[sp:ep]